% this is a part of the habilitation thesis of Max Neunhoeffer

\chapter{Composition trees}

After lots of preparations in the previous chapters
in this chapter the main part of the whole book begins. We begin to talk
about the recognition of matrix groups. We start by formulating
the concept of ``constructive recognition'' and explain the reasoning
behind it in Section~\ref{constrrecog}. In this section we develop
a preliminary formulation of the main problem which will be refined
in the next Section~\ref{recapproach}. There we explain the fundamental
approach to achieve
constructive recognition by means of a ``composition tree''.
The refinement of the formulation of the main
problem there is necessary to allow for an efficient recursive solution.
We chose to ``develop'' the problem formulation in this way in the hope
to provide both a gentle introduction as well as a precise final
formulation with good reasons for its complex structure.

In the following sections we develop a
framework for group recognition that is not only suitable for matrix
groups and projective groups but also allows for the implementation of
the asymptotically best algorithms to handle permutation groups. In
this framework we can switch between different representations of
groups within one composition tree which allows for example to use 
permutation group methods during matrix group recognition, provided
we find some set our matrix group is acting upon.

The general approach to build a composition tree is not new and is
already described in \cite{MatGrpProj}. What is new in our approach
is first the abstraction to allow for different representations
intermixed in the same composition tree and secondly the fact that
we change the generating set in each node of the composition tree
which dramatically decreases the length of the resulting straight
line programs. 

The contents of this chapter stem from joint work with \'Akos Seress
and are an elaboration on the article \cite{AkosMaxISSAC}.

\section{Constructive recognition}
\label{constrrecog}

There are at least two fundamentally different ways to represent groups on
a computer. The first uses a presentation of the group and then
expresses group elements as words in a free group representing
cosets of the normal subgroup generated by the relations. The second
approach uses an ambient group whose elements can be represented and
multiplied directly on the computer, and the group is defined by giving
a list of generators. As ambient groups one can use symmetric groups, general
linear groups or projective groups, since we can store and manipulate
permutations and matrices efficiently on a computer.

In this book we concentrate on the second approach. To formalise our
problem we first write down our assumptions about the ambient group
and then formulate the fundamental problem.

\begin{Hyp}[Ambient group]
\label{ambient}
When we speak about an \emph{ambient group} we mean a finite group that can
be represented on a computer such that we can perform the following tasks:
\begin{itemize}
\item Store and compare group elements using a bounded amount of memory
per element.
\item Multiply group elements.
\item Invert group elements.
\item Compute the order of a group element.
\end{itemize}
\end{Hyp}

\begin{Rem}
All finite symmetric groups fulfil the hypotheses in Section~\ref{ambient}.
We call subgroups of finite symmetric groups \emph{permutation groups}.

For a prime power $q$ the groups $\GL(n,q)$ and $\PGL(n,q)$ also fulfil
the hypotheses. We call subgroups of $\GL(n,q)$ \emph{matrix groups}
and subgroups of $\PGL(n,q)$ \emph{projective groups}.
\end{Rem}

\begin{Problem}[Constructive recognition --- first formulation]
\label{ProbCR1}
Let $\GG$ be an ambient group in the sense of \ref{ambient} and 
assume we are given a generating tuple $(g_1, \ldots, g_k) \in
\GG^k$ for a group
$G := \left< g_1, \ldots, g_k \right> \le \GG$. 

We say that we have \emph{recognised $G$ constructively} if we have 
computed $|G|$ and
prepared a procedure that does the following: Given $g \in \GG$,
decide whether $g \in G$ and if so, express $g$ as a straight line program
in $(g_1, \ldots, g_k)$. This latter procedure is called \emph{constructive
membership test}.
\proofend
\end{Problem}

Note that this formulation will be refined in Sections~\ref{ProbCR2} 
and~\ref{ProbCR3}.

\smallskip
The problem as posed in Problem~\ref{ProbCR1} can be solved easily by just
enumerating the finite group $G$ completely. However, this is neither
a sensible approach nor very interesting. The crucial point missing
in Problem~\ref{ProbCR1} is that we want to do constructive recognition
\emph{efficiently}. To express what we mean by that we use complexity
theory. The class of problems is given by all possible tuples of
generators of subgroups of our ambient groups. We have to specify
what we mean by ``input size'':

\begin{Def}[Input size parameters]
\label{inputsize}
Let $\GG$ be an ambient group in the sense of Hypothesis~\ref{ambient}
and $(g_1, \ldots, g_k) \in \GG^k$. If $\GG$ is either $\GL(n,q)$ or
$\PGL(n,q)$, then the input size of our problem is measured by $n$, $k$
and $\log(q)$. If $\GG$ is the symmetric group on $n$ points then the
input size is measured by $n$ and $k$. We silently set $q := 1$ in that
case such that we can uniformly speak of the input size parameters $n$, $k$
and $q$ in all cases.
\end{Def}

\begin{Rem}
Note that we use $\log(q)$ as one of the parameters of the input size
rather than $q$ itself. The reason behind this is that one needs
$\log(q)$ bits of data to store one finite field element of $\F_q$.
This means that the amount of storage needed for the input matrices is
proportional to $kn^2\log(q)$. Of course, the fact that the discrete
logarithm problem in $\F_q$ prevents us from finding a real polymial
time algorithm for constructive recognition stems from this decision
(compare Section~\ref{thedlp}).
\proofend
\end{Rem}

There is another reason why the formulation in Problem~\ref{ProbCR1} is not
practical. Namely, the straight line programs for elements $g \in G$
written in terms of the original generators can be extremely long. In
addition, for most generating tuples of $G$ it can be tedious if not
impossible to find a method to express group elements in $G$ as straight
programs in these generators. Usually, a recognition procedure first finds
another ``nice'' generating tuple for $G$ for which a good constructive
membership testing procedure is available. To solve the original problem,
such recognition procedures remember, how they got the nice generating
tuple from the original generating tuple by means of a single, rather long
straight line program.

With the above notion of efficiency and these arguments in mind we can now 
formulate a preliminary version of the constructive recognition problem:

\begin{Problem}[Constructive recognition --- preliminary formulation]
\label{ProbCR2}
Let $\GG$ be an ambient group in the sense of \ref{ambient} and 
assume we are given a generating tuple $(g_1, \ldots, g_k) \in
\GG^k$ for a group $G := \left< g_1, \ldots, g_k \right> \le \GG$. 

We say that we have \emph{recognised $G$ constructively} if we have 
computed $|G|$ and a
generating tuple $( g'_1, \ldots, g'_l )$ for $G$, for which we have
prepared a procedure that does the following: Given $g \in \GG$,
decide whether $g \in G$ and if so, express $g$ as a straight line program
in $(g'_1, \ldots, g'_l)$. The new generating tuple may or may not be the
same as the original one.

We assume that we have factorised all integers $q^i-1$ for $1 \le i \le n$
and that we can solve the discrete logarithm problem in all fields $\F_q$
for $1 \le i \le q$ efficiently. 

We call the first phase until $G$ is
recognised constructively the \emph{recognition phase} and the second
phase the \emph{(constructive) membership test phase}.

The aim is that the algorithms for both phases have a runtime that is proved
to be bounded by a fixed polynomial in the input size parameters $n$, $k$
and $q$ in the sense of Definition~\ref{inputsize}.
\proofend
\end{Problem}

Note that this formulation will be refined in Problem~\ref{ProbCR3}.

\begin{Rem}[Randomised algorithm]
We are content with using Las Vegas or Monte Carlo algorithms (see
Section~\ref{montevegas}) provided that we can later on verify our results
deterministically, even if this takes longer than the randomised
recognition step. However, also the verification phase should have a
runtime that is proved to be bounded by a fixed polynomial in the input
size parameters $n$, $k$ and $q$.
\end{Rem}

\section{A recursive approach --- reductions}
\label{recapproach}

Traditionally, the constructive recognition problem for permutation
groups is solved by computing a stabiliser chain and a set of strong
generators using the Schreier-Sims method (see~\cite{Si} and \cite{Ser}). 

Although an analogous method can be used for matrix and projective groups,
this becomes infeasible already for very small values of $n$ since the
occurring orbit lengths can be very large. Also for large base permutation
groups (for a formal definition see Section~\ref{permgrps}) like the
symmetric and alternating groups in their natural representation there
are asymptotically better methods because the stabiliser chains are very long.

Therefore one seeks \emph{reductions} in these cases. A reduction is
a surjective group homomorphism $\varphi : G \to H$ that can be computed
explicitly and for which $H$ is again a subgroup of a possibly different
ambient group. In addition, the homomorphism $\varphi$ must either have
a non-trivial kernel or the group $H$ must be ``easier to handle'' in some
sense. This can for example mean that one of the values $n$, $k$ and
$q$ is smaller for $H$ than for $G$ while the others remain unchanged,
or that the expression $kn^2\log(q)$ becomes smaller such that we need
less memory to store the generators for $H$ than those for $G$.
Another possibility is that for a matrix group $G$ the homomorphic image
$H$ is a permutation group.

Having found a reduction $\varphi : G \to H$ one first tries to recognise
$H$ constructively, then computes generators for the kernel $N$ of
$\varphi$, recognises $N$ constructively and then puts everything together
to achieve a constructive recognition of $G$ from all other intermediate
results. This procedure can be repeated recursively for the image $H$ and
the kernel $N$ such that we end up with a tree (see
Figure~\ref{comptreefig}), where the nodes correspond
to subfactors of the original $G$ and where we have to recognise
the groups in the leaf nodes constructively by other means without
a further reduction.

\begin{figure}
\begin{center}
\includegraphics[width=2.5in]{comptree}
\end{center}
\caption{A composition tree}
\label{comptreefig}
\end{figure}

To make this recursion work we have to say quite carefully what has to
happen at a non-leaf node $G$ such that we actually have solved the
constructive recognition problem for the group $G$ at this node provided
we have solved the corresponding problem for the homomorphic image
$H=\varphi(G)$ and the kernel $N = \ker(\varphi)$. Note that the problem
in our first formulation in Problem~\ref{ProbCR1} could be solved
recursively in this way. However, for our formulation in Problem~\ref{ProbCR2}
this is not possible since we can only express group elements in the nice
generators and not in the original ones. This is the reason why we have to
refine the formulation once more. This time we present the final
formulation:

\begin{Problem}[Constructive recognition --- final formulation]
\label{ProbCR3}
Let $\GG$ be an ambient group in the sense of \ref{ambient} and 
assume we are given a generating tuple $(g_1, \ldots, g_k) \in
\GG^k$ for a group $G := \left< g_1, \ldots, g_k \right> \le \GG$. 

We say that we have \emph{recognised $G$ constructively} if we have 
\begin{itemize}
\item computed $|G|$, and
\item a generating tuple $( g'_1, \ldots, g'_l )$ for $G$, for which we have
\item 
prepared a procedure that does the following: Given $g \in \GG$,
decide whether $g \in G$ and if so, express $g$ as a straight line program
in $(g'_1, \ldots, g'_l)$. Also, we have
\item prepared a procedure that computes, given preimages $(p_1, \ldots,
p_k)$ of $(g_1, \ldots, g_k)$ under some (surjective) homomorphism $\psi
: \hat G \to G$ for some group $\hat G$, preimages under $\psi$ of the
nice generators $(g'_1, \ldots, g'_l)$.
\end{itemize}
The new generating tuple may or may not be the same as the original one.
The last point can for example be achieved by storing a straight line
program that expresses $(g'_1, \ldots, g'_l)$ in terms of $(g_1, \ldots,
g_k)$.

We assume that we have factorised all integers $q^i-1$ for $1 \le i \le n$
and that we can solve the discrete logarithm problem in all fields $\F_q$
for $1 \le i \le q$ efficiently. 

We call the first phase until $G$ is
recognised constructively the \emph{recognition phase} and the second
phase the \emph{(constructive) membership test phase}.

The aim is that the algorithms for both phases have a runtime that is proved
to be bounded by a fixed polynomial in the input size parameters $n$, $k$
and $q$ in the sense of Definition~\ref{inputsize}.

In this book we refer to this problem as the \emph{constructive recognition
problem (CRP)}.
\proofend
\end{Problem}

We claim that this final formulation of the constructive recognition
problem has the property that if $\varphi : G \to H$ is a reduction, then
having solved the constructive recognition problem for $H$ and $N :=
\ker(\varphi)$ in fact suffices to solve the constructive recognition
problem for $G$. To this end we have to
clearly say what the original generators and the new, ``nice'' generators
of our groups $G$, $H$ and $N$ are. This is the purpose of the following
definition.

\begin{Def}[Reduction node]
\label{reducnode}
Let $G = \left< g_1, \ldots, g_k \right> \le \GG$ be as in 
Problem~\ref{ProbCR3}.
We say that we have set up a \emph{reduction node} for $G$, if we have
performed the following steps:
\begin{itemize}
\item[(1)] Finding a surjective group homomorphism $\varphi : G \to H$ for
which we have a procedure to compute $\varphi(g)$ for all $g \in G$.
If this procedure is given an element $g \in \GG \setminus G$ then it
returns either {\fail} or an arbitrary element of $H$.
\item[(2)] Solving Problem~\ref{ProbCR3} for $H = \left< \varphi(g_1),
\ldots, \varphi(g_k) \right>$ with nice generators $(h_1, \ldots, h_m)
\in H^m$.
\item[(3)] Computing preimages $(h'_1, \ldots, h'_s) \in G^m$ under $\varphi$
of the nice generators $(h_1, \ldots, h_s)$ of $H$ using the solution
of (2).
\item[(4)] Computing generators $(n_1, \ldots, n_t) \in N^t$ with $N :=
\ker(\varphi)$ together with a straight line program expressing
$(n_1, \ldots, n_t)$ in terms of $(g_1, \ldots, g_k)$.
\item[(5)] Solving Problem~\ref{ProbCR3} for $N = \left< n_1, \ldots, n_t
\right>$ with nice generators $(n'_1, \ldots, n'_u) \in N^u$.
\end{itemize}
For a reduction node we call the tuple $(h'_1, \ldots, h'_s, n'_1, \ldots,
n'_u)$ its nice generators.
\end{Def}

\begin{Prop}[The recursion works]
Let $G = \left< g_1, \ldots, g_k \right> \le \GG$ be as in 
Problem~\ref{ProbCR3}.
If we have set up a reduction node for $G$, then we have solved the
Problem~\ref{ProbCR3} for $G$.
\end{Prop}
\proofbeg
The group order $|G|$ is equal to the product $|H| \cdot |N|$ since
$\varphi$ is surjective and $N = \ker(\varphi)$.
\proofend

\section{Finding homomorphisms and nice generators}
\label{findhom}

\section{Expressing group elements in terms of the nice generators}
\label{expressslp}

\section{Finding the kernel of a homomorphism}
\label{findkernel}

\section{Asymptotically best algorithms for permutation groups}
\label{permgrps}

