% this is a part of the habilitation thesis of Max Neunhoeffer

\chapter{Composition trees}
\label{chap:comptree}
\index{composition tree}%

After lots of preparations in the previous chapters
the main part of the whole book begins in this chapter. We start to talk
about the recognition of matrix groups. We start by formulating
the concept of ``constructive recognition'' and explain the reasoning
behind it in Section~\ref{constrrecog}. In this section we develop
a preliminary formulation of the main problem which will be refined
in the following Section~\ref{recapproach}. There we explain the fundamental
approach to achieve
constructive recognition by means of a ``composition tree''.
The refinement of the formulation of the main
problem there is necessary to allow for an efficient recursive solution.
We chose to ``develop'' the problem formulation in this way in the hope
to provide both a gentle introduction as well as a precise final
formulation with good reasons for its complex structure.

In the following sections we develop a
framework for group recognition that is not only suitable for matrix
groups and projective groups, but also helps to implement
the asymptotically best algorithms to handle permutation groups. In
this framework we can switch between different representations of
groups within one composition tree, which allows for example to use 
\index{composition tree}%
permutation group methods during matrix group recognition, provided
we find some set our matrix group is acting upon.

The general approach to build a composition tree is not new and is
already described in \cite{MatGrpProj}. What is new in our approach
is first the abstraction to allow for different representations
intermixed in the same composition tree and second the fact that
we change the generating set in each node of the composition tree
which dramatically decreases the length of the resulting straight
line programs. 
\index{straight line program}\index{SLP}%

The contents of this chapter stem from joint work with \'Akos Seress
and are an elaboration on the article \cite{AkosMaxISSAC}.

\section{Constructive recognition}
\label{constrrecog}

\index{constructive recognition}%
There are at least two fundamentally different ways to represent groups on
a computer. The first uses a presentation of the group and then
expresses group elements as words in a free group representing
cosets of the normal subgroup generated by the relations. The second
approach uses an ambient group whose elements can be represented and
multiplied directly on the computer, and the group is defined by giving
a list of generators. As ambient groups one can use symmetric groups, general
linear groups or projective groups, since we can store and manipulate
permutations and matrices efficiently on a computer.

In this book we concentrate on the second approach. To formalise our
problem we first write down our assumptions about the ambient group
and then formulate the fundamental problem.

\begin{Hyp}[Ambient group]
\label{ambient}
\index{ambient group}%
When we speak about an \emph{ambient group} we mean a finite group that can
be represented on a computer such that we can perform the following tasks:
\begin{itemize}
\item Store and compare group elements using a bounded amount of memory
per element.
\item Multiply group elements.
\item Invert group elements.
\item Compute the order of a group element.
\end{itemize}
\end{Hyp}

\begin{Rem}
All finite symmetric groups fulfil the hypotheses in Section~\ref{ambient}.
We call subgroups of finite symmetric groups \emph{permutation groups}.
\index{permutation group}%

For a prime power $q$ the groups $\GL(n,q)$ and $\PGL(n,q)$ also fulfil
the hypotheses. We call subgroups of $\GL(n,q)$ \emph{matrix groups}
and subgroups of $\PGL(n,q)$ \emph{projective groups}.
\index{matrix group}\index{projective group}%
\end{Rem}

\begin{Problem}[Constructive recognition --- first formulation]
\label{ProbCR1}\index{constructive recognition}%
Let $\GG$ be an ambient group in the sense of Hypothesis~\ref{ambient} and 
assume that we are given a generating tuple $(g_1, \ldots, g_k) \in
\GG^k$ for a group
$G := \left< g_1, \ldots, g_k \right> \le \GG$. 

We say that we have \emph{recognised $G$ constructively} if we have 
computed $|G|$ and
prepared a procedure that does the following: Given $g \in \GG$,
decide whether $g \in G$ and if so, express $g$ as a straight line program
in $(g_1, \ldots, g_k)$. This latter procedure is called \emph{constructive
membership test}.
\proofend
\end{Problem}

Note that this formulation will be refined in Sections~\ref{ProbCR2} 
and~\ref{ProbCR3}.

\smallskip
The problem as posed in Problem~\ref{ProbCR1} can be solved easily by just
enumerating the finite group $G$ completely. However, this is neither
a sensible approach nor very interesting. The crucial point missing
in Problem~\ref{ProbCR1} is that we want to do constructive recognition
\emph{efficiently}. To express what we mean by this we use complexity
theory (see Section~\ref{sec:complexity}). 
The class of problems is given by all possible tuples of
generators of subgroups of our ambient groups. We have to specify
what we mean by ``input size''.

\begin{Def}[Input size parameters]
\label{inputsize}
\index{input size parameters}%
Let $\GG$ be an ambient group in the sense of Hypothesis~\ref{ambient}
and $(g_1, \ldots, g_k) \in \GG^k$. If $\GG$ is either $\GL(n,q)$ or
$\PGL(n,q)$, then the input size of our problem is measured by $n$, $k$
and $\log_2(q)$. If $\GG$ is the symmetric group on $n$ points, then the
input size is measured by $n$ and $k$. We silently set $q := 1$ in this
case such that we can uniformly speak of the input size parameters $n$, $k$
and $\log_2(q)$ in all cases.
\end{Def}

\begin{Rem}
Note that we use $\log_2(q)$ as one of the parameters of the input size
instead of $q$ itself. The reason for this is that one needs
$\log_2(q)$ bits of data to store one finite field element of $\F_q$.
This means that the amount of storage needed for the input matrices is
proportional to $kn^2\log_2(q)$. Of course, the fact that the discrete
logarithm problem in $\F_q$ prevents us from finding a real polynomial
time algorithm for constructive recognition stems from this decision
(compare Section~\ref{thedlp}).
\proofend
\end{Rem}

There is another reason why the formulation in Problem~\ref{ProbCR1} is not
practical. Namely, the straight line programs for elements $g \in G$
written in terms of the original generators can be extremely long. In
addition, for most generating tuples of $G$ it can be tedious, if not
impossible, to find a method to express group elements in $G$ as straight
programs in these generators. Usually, a recognition procedure first finds
another ``nice'' generating tuple for $G$ for which a good constructive
\index{nice generators}%
membership testing procedure is available. To solve the original problem,
such recognition procedures remember how they got the nice generating
tuple from the original generating tuple by means of a single, rather long
straight line program.
\index{straight line program}\index{SLP}%

With the above notion of efficiency and these arguments in mind we can now 
formulate another preliminary version of the constructive recognition problem.

\begin{Problem}[Constructive recognition --- preliminary formulation]
\label{ProbCR2}\index{constructive recognition}%
Let $\GG$ be an ambient group in the sense of Hypothesis~\ref{ambient} and 
assume we are given a generating tuple $(g_1, \ldots, g_k) \in
\GG^k$ for a group $G := \left< g_1, \ldots, g_k \right> \le \GG$. 

We say that we have \emph{recognised $G$ constructively} if we have 
computed $|G|$ and a
generating tuple $( g'_1, \ldots, g'_l )$ for $G$ (the nice generators), 
for which we have
prepared a procedure that does the following: Given $g \in \GG$,
decide whether $g \in G$ and if so, express $g$ as a straight line program
\index{straight line program}\index{SLP}%
in $(g'_1, \ldots, g'_l)$. The new generating tuple may or may not be the
same as the original one.

We assume that we have factorised all integers $q^i-1$ for $1 \le i \le n$
and that we can solve the discrete logarithm problem in all fields
$\F_{q^i}$ for $1 \le i \le n$ efficiently. 

We call the first phase until $G$ is
recognised constructively the \emph{recognition phase} and the second
phase in which we decide $g \in G$ the \emph{(constructive) membership test phase}.

The aim is that the algorithms for both phases have a runtime that is proved
to be bounded by a fixed polynomial in the input size parameters $n$, $k$
and $\log_2(q)$ in the sense of Definition~\ref{inputsize}.
\proofend
\end{Problem}

Note that this formulation will be refined in Problem~\ref{ProbCR3}.

\begin{Rem}[Randomised algorithm]
\index{randomised algorithm}\index{algorithm!randomised}%
We are content with using Las Vegas or Monte Carlo algorithms (see
Section~\ref{montevegas}) provided that we can later on verify our results
deterministically, even if this takes longer than the randomised
recognition step. However, also the verification phase should have a
\index{verification}%
runtime that is proved to be bounded by a fixed polynomial in the input
size parameters $n$, $k$ and $\log_2(q)$.
\end{Rem}

\section{A recursive approach --- reductions}
\label{recapproach}
\index{reduction}%

Traditionally, the constructive recognition problem for permutation
groups is solved by computing a stabiliser chain and a set of strong
generators using the Schreier-Sims method (see~\cite{Si} and \cite{Ser}). 

Although an analogous method can be used for matrix and projective groups,
this becomes infeasible already for very small values of $n$ since the
occurring orbit lengths can be very large. Also for large base permutation
groups (for a formal definition see Section~\ref{permgrps}) like the
symmetric and alternating groups in their natural representation there
are asymptotically better methods because the stabiliser chains are very long.

Therefore one seeks \emph{reductions} in these cases. A reduction is
a surjective group homomorphism $\varphi : G \to H$ that can be computed
explicitly and for which $H$ is a subgroup of a possibly different
ambient group. In addition the homomorphism $\varphi$ must either have
a non-trivial kernel or the group $H$ must be ``easier to handle'' in some
sense. This can for example mean that one of the values $n$, $k$ and
$q$ is smaller for $H$ than for $G$ while the others remain unchanged,
or that the expression $kn^2\log_2(q)$ becomes smaller such that we need
less memory to store the generators for $H$ than those for $G$.
Another possibility is that for a matrix group $G$ the homomorphic image
$H$ is a permutation group.

\index{reduction}%
Having found a reduction $\varphi : G \to H$ one first tries to recognise
$H$ constructively, then computes generators for the kernel $N$ of
$\varphi$, recognises $N$ constructively and then puts everything together
to achieve a constructive recognition of $G$ from all other intermediate
results. This procedure can be repeated recursively for the image $H$ and
the kernel $N$ such that we end up with a tree (see
Figure~\ref{comptreefig}), where the nodes correspond
to subfactors of the original $G$ and where we have to recognise
the groups in the leaf nodes constructively by other means without
a further reduction.
\index{leaf}%

\begin{figure}
\caption{A composition tree}
\label{comptreefig}
\index{composition tree}%
\begin{center}
%\includegraphics[width=2.5in]{comptree}
\pgfdeclareimage[width=2.5in]{comptree}{comptree}%
\pgfuseimage{comptree}%
\end{center}
\end{figure}

To make this recursion work we have to say quite carefully what has to
happen at a non-leaf node $G$ such that we actually have solved the
constructive recognition problem for the group $G$ at this node, provided
we have solved the corresponding problem for the homomorphic image
$H=\varphi(G)$ and the kernel $N = \ker(\varphi)$. Note that the problem
in our first formulation in Problem~\ref{ProbCR1} could be solved
recursively in this way. However, for our formulation in Problem~\ref{ProbCR2}
this is not possible since we can only express group elements in the nice
generators and not in the original ones. This is the reason why we have to
refine the formulation once more. This time we present the final
formulation.

%\pagebreak
\begin{Problem}[Constructive recognition --- final formulation]
\label{ProbCR3}\index{constructive recognition!final formulation}%
\index{constructive recognition problem}\index{CRP}%
Let $\GG$ be an ambient group in the sense of Hypothesis~\ref{ambient} and 
assume that we are given a generating tuple $(g_1, \ldots, g_k) \in
\GG^k$ for a group $G := \left< g_1, \ldots, g_k \right> \le \GG$. 

We say that we have \emph{recognised $G$ constructively} if we have 
\begin{itemize}
\item computed $|G|$ and
\item a generating tuple $( g'_1, \ldots, g'_l )$ for $G$ (the nice
generators), for which we have
\item 
prepared a procedure that does the following: Given $g \in \GG$,
decide whether $g \in G$ and if so, express $g$ as a straight line program
\index{straight line program}\index{SLP}%
in $(g'_1, \ldots, g'_l)$. Furthermore, we have
\item prepared a procedure that computes, given preimages $(p_1, \ldots,
p_k)$ of $(g_1, \ldots, g_k)$ under some (surjective) homomorphism $\psi
: \hat G \to G$ for some group $\hat G$, preimages under $\psi$ of the
nice generators $(g'_1, \ldots, g'_l)$.
\end{itemize}
\index{nice generators}%
The new generating tuple may or may not be the same as the original one.
The last point can for example be achieved by storing a straight line
program that expresses $(g'_1, \ldots, g'_l)$ in terms of $(g_1, \ldots,
g_k)$.

We assume that we have factorised all integers $q^i-1$ for $1 \le i \le n$
and that we can solve the discrete logarithm problem in all fields
$\F_{q^i}$ for $1 \le i \le n$ efficiently. 

We call the first phase until $G$ is
recognised constructively the \emph{recognition phase} and the second
phase in which we decide $g \in G$ the \emph{(constructive) membership test phase}.
\index{recognition phase}\index{membership test phase}%
\index{constructive membership test phase}%

The aim is that the algorithms for both phases have a runtime that is proved
to be bounded by a fixed polynomial in the input size parameters $n$, $k$
and $\log_2(q)$ in the sense of Definition~\ref{inputsize}.

In this book we refer to this problem as the \emph{constructive recognition
problem (CRP)}.
\index{CRP}%
\proofend
\end{Problem}

We claim that this final formulation of the constructive recognition
problem has the property that if $\varphi : G \to H$ is a reduction, then
having solved the constructive recognition problem for $H$ and $N :=
\ker(\varphi)$ in fact suffices to solve the constructive recognition
problem for $G$. To this end we have to
clearly say what the original generators and the new, ``nice'' generators
of our groups $G$, $H$ and $N$ are. This is the purpose of the following
definition.

\begin{Def}[Reduction node]
\label{reducnode}
\index{reduction}\index{reduction node}%
Let $G = \left< g_1, \ldots, g_k \right> \le \GG$ be as in 
Problem~\ref{ProbCR3}.
We say that we have set up a \emph{reduction node} for $G$ if we have
performed the following steps:
\begin{itemize}
\item[(1)] Finding a surjective group homomorphism $\varphi : G \to H$ for
which we have a procedure to compute $\varphi(g)$ for all $g \in G$.
If this procedure is given an element $g \in \GG \setminus G$ then it
returns either {\fail} or an arbitrary element in the ambient group of $H$.
\item[(2)] Solving Problem~\ref{ProbCR3} for $H = \left< \varphi(g_1),
\ldots, \varphi(g_k) \right>$ with nice generators $(h_1, \ldots, h_s)$.
\item[(3)] Computing preimages $(h'_1, \ldots, h'_s) \in G^s$ under $\varphi$
of the nice generators $(h_1, \ldots, h_s)$ of $H$ using the solution
of (2).
\index{nice generators}%
\item[(4)] Computing generators $(n_1, \ldots, n_t) \in N^t$ with $N :=
\ker(\varphi)$ together with a straight line program expressing
$(n_1, \ldots, n_t)$ in terms of $(g_1, \ldots, g_k)$.
\index{straight line program}\index{SLP}%
\item[(5)] Solving Problem~\ref{ProbCR3} for $N = \left< n_1, \ldots, n_t
\right>$ with nice generators $(n'_1, \ldots, n'_u) \in N^u$.
\end{itemize}
For a reduction node we call the tuple $(h'_1, \ldots, h'_s, n'_1, \ldots,
n'_u)$ its nice generators.
\end{Def}

\begin{Prop}[The recursion works]
Let $G = \left< g_1, \ldots, g_k \right> \le \GG$ be as in 
Problem~\ref{ProbCR3}.
If we have set up a reduction node for $G$ (in the sense of
Definition~\ref{reducnode}), then we have solved
Problem~\ref{ProbCR3} for $G$.
\end{Prop}
\proofbeg
The group order $|G|$ is equal to the product $|H| \cdot |N|$ since
$\varphi$ is surjective and $N = \ker(\varphi)$.

Recall that we call the tuple $(h'_1, \ldots, h'_s, n'_1, \ldots, n'_u)$
the nice generators for $G$. Since 
\index{nice generators}%
\[ (\varphi(h'_1), \ldots, \varphi(h'_s))
= (h_1, \ldots, h_s) \] 
generates the epimorphic image $H$ of $G$ and
$(n'_1, \ldots, n'_u)$ generates the kernel $N$ the tuple of nice
generators is a generating tuple for $G$.

Given $g \in \GG$, we can test membership in $G$ constructively as follows:
First we try to map $g$ with $\varphi$. If this fails, the element $g$
does not lie in $G$ by our assumptions in \ref{reducnode}.(1). Otherwise
denote the result of the procedure assumed in \ref{reducnode}.(1) by $h$, 
it lies in the ambient group of $H$. 
Note that in this case it can still be that
$g$ is not contained in $G$, regardless whether $h$ lies in $H$ or not! 

Then we try to express $h$ as a straight 
line program $s_1$ in the nice generators $(h_1, \ldots, h_s)$ of $H$. If this
\index{straight line program}\index{SLP}%
fails, $h$ is not contained in $H$ and thus $g$ is not contained in
$G$. Otherwise we evaluate $s_1$ with inputs
$(h'_1, \ldots, h'_s)$, which are preimages of the nice generators of $H$ under
$\varphi$. If $g$ is contained in $G$, the result $h'$ is a preimage 
under $\varphi$ of $h = \varphi(g)$. Thus $m := h'^{-1}\cdot g$ is contained
in the kernel $N$ of $\varphi$. We try to express $m$ as a straight
line program $s_2$ in $(n'_1, \ldots, n'_u)$. If this fails, 
\index{straight line program}\index{SLP}%
$m$~is not contained in $N$ and thus $g$ is not contained in $G$. Otherwise,
we put together the straight line programs $s_1$ and $s_2$ to form
one big straight line program $s$ that reaches $h'm$ from the input 
\index{straight line program}\index{SLP}%
$(h'_1, \ldots, h'_s, n'_1, \ldots, n'_u)$. In this case we have proved
that $g$ lies in $G$.
\proofend

\medskip
We conclude this section with a short overview of the rest of the chapter
and an outlook onto the following ones:
We have now found our final formulation of the constructive
recognition problem and we have shown a general approach for its solution
by means of reduction. In the next Section~\ref{findkernel} we explain how
to find the kernel $N$ of a homomorphism as in Definition~\ref{reducnode}
once we have constructively recognised the epimorphic image $H$. After
that,
in Section~\ref{findhom}, we describe a generic framework to organise the
finding of reductions using a database of different methods. Finally we
explain how this whole framework can be used to implement the
asymptotically best algorithms for arbitrary permutation groups.
The following chapters cover the question how to find reductions
and solve the constructive recognition problem for matrix groups and
projective groups.

\section{Finding the kernel of a homomorphism}
\label{findkernel}
\index{finding kernels}\index{kernel of a homomorphism}%

In this section we assume that we are in the situation described in
Problem~\ref{ProbCR3} and want to construct a reduction node in the sense
of Definition~\ref{reducnode}. We assume that we can produce evenly
distributed random elements in $G$ (see Section~\ref{randomelts}).

Assume that we have already found a homomorphism
$\varphi : G \to \HH$ into some ambient group $\HH$ in the sense of
Hypothesis~\ref{ambient}, such that we can map arbitrary group elements
$g \in G$ with $\varphi$. Then we set $H := \left< \varphi(g_1), \ldots,
\varphi(g_k) \right>$ and constructively recognise $H$ which produces
among other things nice generators $(h_1, \ldots, h_s)$ of $H$. Another
result of the recognition is that we can compute preimages $(h'_1, \ldots,
h'_s) \in G^s$ of the $(h_1, \ldots, h_s)$ under $\varphi$.

Equipped with all this data and methods we can now do the following
for an arbitrary element $g \in G$: Map it with $\varphi$ into $H$
and call $h := \varphi(g)$. Then find a straight line program $s$ reaching
\index{straight line program}\index{SLP}%
$h$ from $(h_1, \ldots, h_s)$ and evaluate it on $(h'_1, \ldots, h'_s)$
to get an element $h' \in G$ with the property that
$\varphi(g)=\varphi(h') = h$, thus $h'^{-1}\cdot g$ lies in the kernel $N$
of $\varphi$. For this construction we have the following result.

\begin{Prop}[Even distribution of kernel elements]
\label{evendistker}
If $x_1, x_2, \ldots, x_m$ are evenly distributed random elements in $G$,
the above procedure produces evenly distributed random elements in
$N$.
\end{Prop}
\proofbeg
Since $H \cong G/N$, the elements of $H$ correspond to cosets of $N$ in
$G$. Our constructive membership test in $H$ produces a straight
line program for every element $h \in H$ and the evaluation of this
\index{straight line program}\index{SLP}%
program on the preimages $(h'_1, \ldots, h'_s)$ thus chooses exactly one
element of the coset $G$ of $N$ that is mapped to $h$. Since the $x_i$ are evenly
distributed in the whole of $G$, their images under $\varphi$ are
distributed evenly in $H$. Multiplying $x_i$ with the inverse of the
chosen coset representative in the coset $x_iN$ amounts to mapping
$x_i N$ bijectively onto $N$. Again by the even distribution of the $x_i$
it follows that the elements $y_i$ are evenly distributed in $N$.
\proofend

\smallskip
Proposition~\ref{evendistker} now allows to produce evenly distributed
elements in $N$. To find a generating tuple of $N$ we simply produce
a certain amount of random elements. Since every proper subgroup of $N$ 
has index at least $2$ in $N$, the probability to increase the
subgroup that is generated by the already produced elements is at least 
$1/2$ for every new element. Thus the probability to find a generating
set for the whole of $N$ is very high, provided we produce enough random
elements. Then we can compute the normal closure using
the methods in \cite[Chapter 2]{Ser}, in particular
\cite[Theorem~2.3.9]{Ser}.


\medskip
Sometimes we not only recognise $H$ constructively in the sense of
Problem~\ref{ProbCR3}, but also find a presentation in terms of the 
nice generators. This happens mostly, but not exclusively, if $H$ is an 
almost simple group. In this case we have the following result.

\begin{Prop}[Kernel if a presentation of $H$ is known]
\label{kernelpres}
Assume that in the above situation $H$ is isomorphic to the
finitely presented group with generators $\bar f_1, \ldots, \bar f_s$
subject to relations $r_1, \ldots, r_m$ given as a straight line
\index{straight line program}\index{SLP}%
program $t$ in terms of generators of the free group $F=\left< f_1, \ldots,
f_s\right>$. Let $(r'_1, \ldots,
r'_m)$ be the result of $t$ evaluated on $(h'_1, \ldots, h'_s)$, that is,
the $(r'_1, \ldots, r'_m)$ are all preimages of the identity under $\varphi$. 
Let further $x_i$ for $1 \le i \le k$ be elements in $\left< h'_1, \ldots, 
h'_s \right>$ with $\varphi(x_i) = \varphi(g_i)$ obtained by the procedure 
described directly before Proposition~\ref{evendistker}, and set 
$y_i := x_i^{-1} \cdot g_i \in N$. Then the kernel $N$ of
$\varphi$ is the normal closure in $G$ of the group generated by
$(y_1, \ldots, y_k, r'_1, \ldots, r'_m)$.
\end{Prop}
\proofbeg
Clearly, all the elements $y_i$ and $r'_i$ lie in $N$. Since $N$ is a
normal subgroup of $G$, the normal closure $\tilde N$ of the group generated
by $(y_1, \ldots, y_k, r'_1, \ldots, r'_m)$ is contained in $N$.

On the other hand every element $w$ of $N$ is a product of the generators
$g_i$. Thus, setting $w = g_{i_1} \cdots g_{i_t}$ for some numbers
$i_j \in \{ 1, \ldots, k \}$, we get
\[ w = x_{i_1} x_{i_1}^{-1} g_{i_1} \cdots x_{i_t} x_{i_t}^{-1} g_{i_t}
     = x_{i_1} y_{i_1} \cdots x_{i_t} y_{i_t}
     = \tilde w \cdot x, \]
where $\tilde w$ is a product of some $G$-conjugates of the $y_{i_j}$
and $x$ is a product of the $h'_i$ that lies in $N$. Since the $h'_i$
are preimages of the generators $h_i$ of $H$ and $r'_i$ are constructed
by the relations $r_i$ the element $x$ lies in the normal closure
of the subgroup generated by the $r'_i$ and thus $\tilde N = N$.
\proofend

\begin{Rem}[Computing the kernel with a given presentation of $H$]
Using the results of the constructive recognition of $H$ we
can explicitly compute preimages $r'_i$ of the relations $r_i$ since
the latter are given as straight line programs in terms of the nice
\index{straight line program}\index{SLP}%
generators of $H$. Thus we can explicitly compute all the generators in
Proposition~\ref{kernelpres}. The normal closure can be computed using
the methods in \cite[Chapter 2]{Ser}, in particular
\cite[Theorem~2.3.9]{Ser}.
\end{Rem}

In this Section~\ref{findkernel} 
we have shown that to set up a reduction node we only need
an explicitly computable homomorphism $\varphi$ from $G$ into some
ambient group $\HH$. Given this, one can constructively recognise the
image, compute generators for the kernel and constructively recognise it,
thereby fulfilling all requirements for a reduction node.


\section{Finding homomorphisms and nice generators}
\label{findhom}
\index{nice generators}%

During the recursive recognition procedure we have to solve
Problem~\ref{ProbCR3} at every node of the composition tree, either
by finding a reduction and setting up a reduction node or by solving 
the constructive recognition problem directly. In this section we describe
a generic framework to organise an algorithm to achieve this.

We have to explore every group $G$ as in Problem~\ref{ProbCR3} 
occurring in our tree to find out whether we 
can solve the constructive recognition 
problem or what kind of homomorphism can be 
applied to it. To this end, the framework holds a collection
of so-called ``find homomorphism'' methods in stock. A find homomorphism
method's objective is either to find a homomorphism $\varphi: G \to H$
onto some subgroup $H$, thereby setting up a reduction node and 
creating a new non-leaf node, or to
solve the constructive recognition 
problem directly, which can but does not always have to find
an isomorphism to some known group.

For each type of groups (permutation groups, matrix groups, projective
groups and black-box
groups), the system has a database of find homomorphism methods.
We call the procedure that decides which methods to try and in which order 
the ``method selection''. For this purpose we define a very simple and yet 
versatile algorithm which we will describe now. It is usable independently
from group recognition, but we will explain it here in the context of
our generic recognition procedure. Note that this new method selection
procedure is not to be confused with the {\GAP} (see \cite{GAP4}) method
selection. 
\index{method selection}%

The group recognition procedure for a node just calls the generic method
selection procedure with the database of find homomorphism methods
corresponding to the type of the group.

The methods in each database are ranked, thereby defining a total
order. The method selection procedure calls the methods one after another,
starting with high ranks. A find homomorphism method reports back to
the generic procedure by returning one of the four values in
Table~\ref{methselresults}.

\begin{table}[ht]
\caption{Possible results of a find homomorphism method}
\label{methselresults}
\vspace*{3mm}
\begin{tabular}{lp{4.2in}}
\texttt{true}: &
   The method was successful and has either set up a
   leaf or a non-leaf node. For details see below. \\
\texttt{fail}: &
   The method has failed to find a homomorphism or
   to solve the constructive recognition problem, at least temporarily. \\
\texttt{false}: &
   The method has failed and will do so always for
   the group $G$ in question, such that there is no point in trying
   this method again for the group $G$. \\
\texttt{NotApplicable}: &
   The method is currently not applicable
   but it might become applicable later, provided new knowledge is
   found out about the group $G$.
\end{tabular}
\end{table}

The first case is the only one that terminates the recognition procedure
for the current node in the composition tree.
All other cases make it necessary to try other methods. The difference
between these latter three cases lies in the fact, how the generic
procedure chooses the next method called. If a method returns
\texttt{NotApplicable}, then the method selection just calls the next
method in the database. In the other two cases \texttt{false} and 
\texttt{fail}, the method selection again starts with the highest ranked
method, but skips all methods that have already been tried and
have failed by returning either \texttt{false} or \texttt{fail}.

When all available methods either have declared themselves
\texttt{NotApplicable} or have failed, the method selection 
starts all over again, now calling methods again that have returned
\texttt{fail} once, but of course skipping methods that have returned
\texttt{false}. This whole process is repeated until each method has
failed a configurable number of times, when the method selection
finally gives up.

We hope that this design is simple enough to keep an overview of what is
tried in which order to prove the whole algorithm to work correctly,
and yet versatile enough to implement a wide range of different algorithms,
in which ``trying different methods'' is involved. Now we explain
the rationale behind some of the features of this procedure.

The idea behind the fact that after a method having returned
\texttt{fail} or \texttt{false} the method selection starts again
with the highest ranked method is that even a failed method might
have found out new information about the group, thereby making
higher ranked methods that have refused to work earlier by
returning \texttt{NotApplicable} newly applicable.

In the {\GAP} system, information about a group $G$ is collected in
so-called {\em attributes} (for example,
\index{attributes in GAP@attributes in {\GAP}}%
a permutation group object may store as an attribute whether it is transitive
or not), but we may also acquire the information that 
$G$ is simple or that it is solvable, or we may know $|G|$, etc. 
Note that at any given time the value of an attribute for a given group
object can already be computed or not, and the group object can learn new
information about itself during its lifetime. This feature is already
part of the {\GAP} system library. 

Further attributes may be
computed when the method selection tries to apply
different find homomorphism methods while processing the current group $G$.
Therefore a find homomorphism method can just look whether or not
a certain attribute is already known and then decide if it starts
to work or declares itself \texttt{NotApplicable}. With new attributes
being computed, this decision might be changed. By convention, a method
should never use much computation time to find out that it is not
applicable.

The idea behind a method returning \texttt{fail} is that often
randomised algorithms are used that have the potential to fail,
but still may succeed when tried again. The ranking and the failure 
probabilities of course have to be tuned carefully to assemble
a sensible recognition system.

Once a method returns \texttt{true} it reports whether it has found a
reduction or has solved the constructive recognition problem by other
means. In the first case the generic machinery sets up a recognition node
as described in Sections~\ref{recapproach} and \ref{findkernel}. In the
other case a leaf in the composition tree is built and the find
\index{leaf}%
homomorphism method that returned \texttt{true} is responsible for the
data and methods to do constructive membership testing in the group 
of the node. In this way a composition tree is built recursively using the
database of find homomorphism methods together with the generic code
organising the recursive framework.

Another important feature of this framework is the following. Quite often
a find homomorphism method derives new information about the group in
question that can be used further down in the composition tree most notably
in the homomorphic image or the kernel of the group homomorphism found.
For example it might already know that it has set up an isomorphism such
that the kernel is trivial or it might know that the homomorphic image of a
matrix group is a permutation group. To communicate such information to the
methods used further down in the tree there is an infrastructure to hand
down so-called ``hints''. These hints might for example consist of additional
\index{hints}%
knowledge about the group such that certain find homomorphism methods
are particularly well suited. Having this type of information available
further down in the tree helps choosing the best find homomorphism method
first. Furthermore, even a failed method can store already 
obtained data about the group in the data structure of the node it tried
to work on. In this way methods that are called later in the method
selection process can profit from this additional information. In the
chapters to come in this book we describe find homomorphism methods
and mention such hints that can help other methods along with the
description of the methods.

We illustrate the generic method selection described in this section
in the next Section~\ref{permgrps}, where we explain how it is used to
glue together the asymptotically best algorithms currently known for
the handling of permutation groups to set up a constructive recognition
algorithm for the case that the ambient group is a symmetric group.


\section{Asymptotically best algorithms for permutation groups}
\label{permgrps}

Traditionally, the constructive recognition problem for permutation
groups is solved by computing a stabiliser chain and a set of strong
generators using the Schreier-Sims method (see~\cite{Si} and \cite{Ser}). 

However, this method does not work very efficiently for so-called
``large base groups''. We start by developing the necessary language
from the complexity theory of permutation groups.

\begin{Def}[Base of a permutation group]
\index{base of a permutation group}\index{stabiliser chain}%
Let $G \le S_n$ be a subgroup of the symmetric group on $\{1,\ldots,n\}$.
A tuple $B \in \{ 1, \ldots, n\}^l$ is called a \emph{base of $G$ with
length $l$}, if only the identity of $G$ fixes every point in $B$: 
\[ \{ g \in G \mid b_i^g = b_i \mbox{ for all } 1 \le i \le l \} = \{ \id \}. \]
The \emph{stabiliser chain} belonging to a base $B$ is the chain of
subgroups
\[ G \ge G_{b_1} \ge G_{b_1,b_2} \ge \cdots \ge G_{b_1,\ldots,b_k} =
\{\id\}, \]
where $G_{b_1, \ldots, b_j} =
\{ g \in G \mid b_i^g = b_i \mbox{ for all } 1 \le i \le j \}$.
\end{Def}

Obviously, the length of every stabiliser chain for a permutation group 
$G$ is at least as big as the length of a shortest base of $G$.
This is the reason why computing stabiliser chains is not efficient
for groups without a ``reasonably short'' base. Of course, the
Schreier-Sims method does not necessarily find a shortest possible base.
However, one can implement the method such that in the resulting
stabiliser chain all inclusions are proper.
Therefore we consider not the shortest possible base length but
an upper bound for the length of a base.

\begin{Prop}[Maximal base length]
If $G \le S_n$ then every base of $G$, for which all inclusions in its
stabiliser chain are proper, has length at most $\lceil \log_2(|G|) \rceil$.
\end{Prop}
\proofbeg
The index of one stabiliser in the previous one in the stabiliser chain is
at least $2$.
\proofend

To formulate precise complexity statements we have to talk about families
of permutation groups.

\begin{Def}[Families of small and large base groups]
\label{SmallLargeBase}
\index{small base groups}\index{large base groups}%
Let $\calF$ be a family of permutation groups, all embedded into
possibly different symmetric groups $S_n$ and given by generating tuples. 
For a $G \in \calF$ we denote 
by $n(G)$ the $n$ of the symmetric group $S_n$ into which $G$ is embedded
and by $k(G)$ the number of generators by which $G$ is defined.

The family $\calF$ is called \emph{a family of small base groups} if there
is a positive constant $c$ such that $\log_2(|G|) \le \log^c_2(n(G))$ for all
$G \in \calF$. If there is no such constant then $\calF$ is called
\emph{a family of large base groups}.
\end{Def}

\begin{Rem}[A single permutation group]
Note that the terms ``large base group'' and ``small base group'' are
\emph{not defined} for a single permutation group $G$ although one is
sometimes tempted to call a member of a family of large base groups
a ``large base group''. However, complexity statements about algorithms
only make sense for families of inputs and thus it is only sensible to
talk about ``small'' or ``large'' bases in the context of families of
permutation groups.
\end{Rem}

The motivation for the terms ``family of large/small base permutation
groups'' is the following result.

\begin{Theo}[Complexity of the Schreier-Sims method]
Let $\calF$ be a family of small base groups. Then a randomised version
of the Schreier-Sims method computes a base and strong generators
for any $G \in \calF$ in nearly-linear time in the input size $k(G)\cdot
n(G)$, that is the runtime is bounded by a function in
$O(k(G)n(G) \cdot \log^c_2(n(G)))$ for some constant $c$.
\end{Theo}
\proofbeg See \cite{nearlylin} or \cite[Theorem 4.5.5]{Ser}. \proofend

\medskip
If a permutation group $G \le S_n$ is given by a list of generators, it
is at first glance not clear, whether it has a short base. Of course,
we want to avoid to compute a base by an application of the Schreier-Sims
method if there is no short base.

To solve Problem~\ref{ProbCR3} for a permutation group we use the method
selection procedure described in Section~\ref{findhom}. In the following we
describe the methods that are used in this process. An overview of these 
methods is given in Table~\ref{permdb}. The basic idea is to recognise
and handle alternating composition factors without computing a stabiliser 
chain.

\begin{table}[ht]
\caption{Find homomorphism methods for permutation groups}
\index{finding homomorphism!for permutation groups}%
\label{permdb}
\begin{center}
\begin{tabular}{|c|l|l|c|}
\hline
Rank & Name & Action & Hom/Leaf \\
\hline
\hline
50 & \texttt{NonTransitive} & Restrict to orbit & Hom \\
\hline
40 & \texttt{Giant} $A_n/S_n$ & Find standard generators & Leaf \\
\hline
30 & \texttt{Imprimitive} & Find block system & Hom \\
\hline
20 & \texttt{Jellyfish} & Find standard generators & Leaf \\
\hline
10 & \texttt{StabilizerChain} & Compute a base and strong generators & Leaf \\
\hline
\end{tabular}
\end{center}
\end{table}

The method with the highest rank $50$ is the reduction method called
\texttt{NonTransitive} for intransitive groups. It first tests whether
$G$ is transitive and if not, constructs an explicitly
computable homomorphism by restricting the action to one of the orbits in the
permutation domain. If $G$ turns out to be transitive, the
\texttt{NonTransitive} method immediately returns \texttt{false}
indicating that it can never be successful for the group $G$.

The next method \texttt{Giant} with rank $40$ tries to decide, whether the
group $G \le S_n$ is a ``giant'', that is, it is either equal to
$A_n$ or to $S_n$ itself. In these two cases, there are better methods than
computing a stabiliser chain to solve the constructive recognition problem.
These methods are described in detail in \cite[Section~10.2]{Ser}, see
in particular \cite[Section~10.2.4]{Ser}. The algorithm described there
is one-sided Las Vegas in the following sense:  If it recognises $A_n$ or
$S_n$, the result is guaranteed to be correct. If $G$ is not a giant, it
fails very quickly. With a small error probability it can fail even if
$G$ is equal to $A_n$ or $S_n$. Thus, the method \texttt{Giant} returns
\texttt{fail} in case of failure meaning that it could be called later
on to try again. However, in the setup described here this will not
happen, since later methods will always succeed, even if they take a
very long time.

The third method \texttt{Imprimitive} with rank $30$ tries to find a block
system using the algorithm described in \cite[Section~5.5.1]{Ser}. If it 
finds one, it constructs a homomorphism onto the action on the set of
blocks. Since the algorithm is deterministic, it returns \texttt{false}
if no block system is found and the group $G$ is proved to be primitive.

Note that in the case that the \texttt{Imprimitive} method finds a block
system, it hands the information about the blocks down to the node that is
set up for the kernel. This allows firstly to use a different method to
create generators for the kernel since one needs often much more elements
to generate a subgroup of a repeated direct product than usual. Secondly,
the system can use a special find homomorphism
method for the kernel that produces a balanced composition tree, which 
\index{composition tree!balanced}\index{balanced tree}%
is more efficient both during the recognition phase and the membership
testing phase. Here the infrastructure in our framework to hand down 
hints to kernel and homomorphic image of a homomorphism is used 
\index{hints}%
extensively.
\enlargethispage{1\baselineskip}

The fourth find homomorphism method \texttt{Jellyfish} with rank $20$
handles another special case in which the Schreier-Sims method does
not work efficiently. This case is that an alternating or symmetric
group on $\{1,\ldots,m\}$ acts on $n = {m \choose k}^r$ $r$-tuples
of $k$-subsets of $\{1,\ldots,m\}$. Of course, the action is not
given in this way but simply as an action on the set $\{1,\ldots,n\}$
and the problem is to identify each number in $\{1,\ldots,n\}$ with
an $r$-tuple of $k$-subsets of $\{ 1, \ldots, m\}$. In fact, the
algorithm does not solve this latter problem but tries to guess
$m$, $k$ and $r$ and directly find standard generators for $A_m$ or
$S_m$. A deterministic algorithm to solve this problem is described
in \cite[Section~4]{fastmanag} and a faster randomised one in
\cite{Jellyfish}.

Finally, if everything that has previously been tried has failed, we
compute a base and strong generators using the Schreier-Sims method. This
is done by the method called \texttt{StabilizerChain} with rank $10$.

This setup tries the right things in the right order to handle groups
with small as well as with large bases and thus implements a framework to
handle all permutation groups with the asymptotically best algorithms
known.

