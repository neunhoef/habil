% this is a part of the habilitation thesis of Max Neunhoeffer

\chapter{Composition trees}

After lots of preparations in the previous chapters
in this chapter the main part of the whole book begins. We begin to talk
about the recognition of matrix groups. We start by formulating
the concept of ``constructive recognition'' and explain the reasoning
behind it in Section~\ref{constrrecog}. Then we explain the fundamental
approach to achieve
constructive recognition by means of a ``composition tree'' in
Section~\ref{recapproach}. We develop a
framework for group recognition that is not only suitable for matrix
groups and projective groups but also allows for the implementation of
the asymptotically best algorithms to handle permutation groups. In
this framework we can switch between different representations of
groups within one composition tree which allows for example to use 
permutation group methods during matrix group recognition, provided
we find some set our matrix group is acting upon.

The general approach to build a composition tree is not new and is
already described in \cite{MatGrpProj}. What is new in our approach
is first the abstraction to allow for different representations
intermixed in the same composition tree and secondly the fact that
we change the generating set in each node of the composition tree
which dramatically decreases the length of the resulting straight
line programs. 

The contents of this chapter stem from joint work with \'Akos Seress
and are an elaboration on the article \cite{AkosMaxISSAC}.

\section{Constructive recognition}
\label{constrrecog}

There are at least two fundamentally different ways to represent groups on
a computer. The first uses a presentation of the group and then
expresses group elements as words in a free group representing
cosets of the normal subgroup generated by the relations. The second
approach uses an ambient group whose elements can be represented and
multiplied directly on the computer and defines the group by giving
a generating set. As ambient groups one can use symmetric groups, general
linear groups or projective groups, since we can store and manipulate
permutations and matrices efficiently on a computer.

In this book we concentrate on the second approach. To formalise our
problem we first write down our assumptions about the ambient group
and then formulate the fundamental problem.

\begin{Hyp}[Ambient group]
\label{ambient}
When we speak about an \emph{ambient group} we mean a finite group that can
be represented on a computer such that we can perform the following tasks:
\begin{itemize}
\item Store and compare group elements.
\item Have available the identity element.
\item Multiply group elements.
\item Invert group elements.
\item Compute the order of a group element.
\end{itemize}
\end{Hyp}

\begin{Rem}
All finite symmetric groups fulfil the hypotheses in Section~\ref{ambient}.
We call subgroups of finite symmetric groups \emph{permutation groups}.

For a prime power $q$ the groups $\GL(n,q)$ and $\PGL(n,q)$ also fulfil
the hypotheses. We call subgroups of $\GL(n,q)$ \emph{matrix groups}
and subgroups of $\PGL(n,q)$ \emph{projective groups}.
\end{Rem}

\begin{Problem}[Constructive recognition --- first formulation]
\label{ProbCR1}
Let $\mathcal{G}$ be an ambient group in the sense of \ref{ambient} and 
assume we are given a generating tuple $(g_1, \ldots, g_k) \in
\mathcal{G}^k$ for a group
$G := \left< g_1, \ldots, g_k \right> \le \mathcal{G}$. 

We say that we have \emph{recognised $G$ constructively} if we have 
computed $|G|$ and a
generating tuple $( g'_1, \ldots, g'_l )$ for $G$, for which we have
prepared a procedure that does the following: Given $g \in \mathcal{G}$,
decide whether $g \in G$ and if so, express $g$ as a straight line program
in $(g'_1, \ldots, g'_l)$. The new generating tuple may or may not be the
same as the original one.
\end{Problem}

\begin{Rem}
The problem as posed in \ref{ProbCR1} can be solved easily by just
enumerating the finite group $G$ completely. However, this is neither
a sensible approach nor very interesting. The crucial point missing
in \ref{ProbCR1} is that we want to do constructive recognition
\emph{efficiently}. 
\end{Rem}

\section{A recursive approach}
\label{recapproach}

\section{Finding homomorphisms and nice generators}
\label{findhom}

\section{Expressing group elements in terms of the nice generators}
\label{expressslp}

\section{Finding the kernel of a homomorphism}
\label{findkernel}

\section{Asymptotically best algorithms for permutation groups}
\label{permgrps}

