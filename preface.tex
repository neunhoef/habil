% this is a part of the habilitation thesis of Max Neunhoeffer

\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}

\renewcommand{\thechapter}{0}

This chapter gives a brief overview of the mathematical area and the 
content of the present book and finishes with the acknowledgements.

\section{The Goal}

The mathematical area of the present book is computational group
theory. The ultimate goal of this theory is to be able to do
computations in and with groups. Traditionally there are several ways
to implement groups on computers. One way is to work with finitely
presented groups, that is by specifying generators and relations.
Another is to use group actions to actually store,
multiply, invert and compare group elements in groups. Using 
actions on sets leads to the study of permutation groups, using linear
actions leads to the study of matrix groups and using projective
actions leads to the study of projective groups, by which we mean
groups in which the elements are invertible matrices modulo scalars.
Considering other actions to represent groups on a computer is
possible (compare for example \cite{Kohl}) but up to now not studied much.

For finite permutation groups there are highly efficient
algorithms to compute the order of a group, a composition series,
centralisers of elements, stabilisers, $p$-Sylow subgroups, find
normal subgroups, maximal subgroups, group homomorphisms, test
membership of group elements and the like.
Standard techniques use stabiliser chains, base and strong generating
set methods (for a good account of the known methods see \cite{Ser}). 
These algorithms are implemented in computer algebra
systems like {\GAP} (see \cite{GAP4}) and {\MAGMA} (see \cite{Magma})
and the status of this area can justifiably be called satisfactory.

A few interesting experiences have been made from this area. One is that 
complexity theory,
\index{complexity theory}
which is the study of the asymptotic behaviour of the runtime of algorithms 
as the problem size tends to infinity\footnote{for a brief discussion see 
Section~\ref{sec:complexity}}, has been a very important tool to
devise efficient algorithms and to implement them. In particular,
worst-case analysis of the complexity of algorithms has shown that
\index{complexity}
it is in practice worthwhile to first exclude a few nasty cases ---
for which special methods apply --- before applying standard methods,
which would be disastrously slow in these nasty cases. Large base
groups (see Section~\ref{SmallLargeBase}) are an example for such
nasty cases for stabiliser chain methods.
Another interesting
experience from the study of algorithms for finite permutation groups 
is that randomised algorithms, followed by some kind of
deterministic verification of the results, have been very successful.
\index{verification}

The situation for matrix groups over finite fields, which are subgroups 
of some general linear group $\GL(n,q)$ --- the group of all
invertible $n \times n$-matrices with entries in the finite field
$\F_q$ with $q$ elements with matrix multiplication as product ---
is less satisfactory. Roughly speaking, if one enters a few
elements $g_1, \ldots, g_k$ of some $\GL(n,q)$ into a computer algebra 
system like {\GAP} or {\MAGMA}, it is in general quite limited what
these systems can tell you about the subgroup of $\GL(n,q)$ that is
generated by the elements $g_i$.

So the ultimate goal in this subarea of computational group theory
is to be able to do as much as possible with these matrix groups over
finite fields, guided by what is already possible efficiently with
finite permutation groups. The general idea is to use the complexity
analysis of algorithms as a tool to come up with ``efficient''
algorithms. Generally, an algorithm is considered to be ``good'' if
its runtime is bounded from above by a polynomial in the size of the
input.

First goal: Constructive recognition (compare to sifting)
Matrix group recognition project. A bit of history.

Basic approach, rough sketch.

\section{The Book}

This book gives an overview over the current state of the art and
shows some contributions of the author. Collaborations.
Implementations.

Work to do (in particular C9 groups).

Not mentioned: New methods for matrices over finite fields using
floating point numbers, details on C9, Mark Stather's work, further
algorithms building on top of constructive recognition. Black box
groups. Global analysis of the whole procedure of building a
composition tree.

Structure of this book. Go through chapters. Explain authors.

\section{Acknowledgements}

Acknowledgements. Thanks.

In particular:

RWTH, Gerhard Hiss, Alice Cheryl, UWA, Akos, Ohio State, St Andrews, Colva, Jon,
Steve. Proofreading: Colva, Papa, Anja.

\renewcommand{\thechapter}{\Roman{chapter}}
