% this is a part of the habilitation thesis of Max Neunhoeffer

\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}
\markboth{Preface}{The Goal}

\renewcommand{\thechapter}{0}

This chapter gives a brief overview of the mathematical area and the 
content of the present book and finishes with the acknowledgements.

\section{The Goal}

The mathematical area of the present book is computational group
theory. The ultimate goal of this theory is to be able to do
computations in and with groups. Traditionally there are several ways
to implement groups on computers. One way is to work with finitely
presented groups, that is by specifying generators and relations.
Another is to use group actions to actually store,
multiply, invert and compare group elements in groups. Using 
actions on sets leads to the study of permutation groups, using linear
actions leads to the study of matrix groups and using projective
actions leads to the study of projective groups, by which we mean
groups in which the elements are invertible matrices modulo scalars.
Considering other actions to represent groups on a computer is
possible (see for example \cite{Kohl}) but up to now not studied much.

For finite permutation groups there are highly efficient
algorithms to compute the order of a group, a composition series,
centralisers of elements, stabilisers, $p$-Sylow subgroups, to find
normal subgroups, maximal subgroups, group homomorphisms, to test
membership of group elements and the like.
Standard techniques use stabiliser chains, base and strong generating
set methods, for a good account of the known methods see \cite{Ser}. 
These algorithms are implemented in computer algebra
systems like {\GAP} (see \cite{GAP4}) and {\MAGMA} (see \cite{Magma})
and the status of this area can justifiably be called satisfactory.

A few interesting experiences have been made from this area. One is that 
complexity theory,
\index{complexity theory}%
which is the study of the asymptotic behaviour of the runtime of algorithms 
as the problem size tends to infinity\footnote{For a brief discussion see 
Section~\ref{sec:complexity}.}, has been a very important tool to
devise efficient algorithms and to implement them. In particular,
worst-case analysis of the complexity of permutation group 
algorithms has shown that
\index{complexity}%
it is in practice worthwhile to first exclude a few nasty cases ---
for which special methods apply --- before applying standard methods,
which would be disastrously slow in these nasty cases. Large base
groups (see Section~\ref{SmallLargeBase}) are an example for such
nasty cases for stabiliser chain methods.
Another interesting
experience from the study of algorithms for finite permutation groups 
is that randomised algorithms, followed by some kind of
deterministic verification of the results, have been very successful.
\index{verification}%

The situation for matrix groups over finite fields, which are subgroups 
of some general linear group $\GL(n,q)$ --- the group of all
invertible $n \times n$-matrices with entries in the finite field
$\F_q$ with $q$ elements with matrix multiplication as product ---
is less satisfactory. Roughly speaking, if one enters a few
elements $g_1, \ldots, g_k$ of some $\GL(n,q)$ into a computer algebra 
system like {\GAP} or {\MAGMA}, it is in general quite limited what
these systems can tell you about the subgroup of $\GL(n,q)$ that is
generated by the elements $g_i$.

So the ultimate goal in this subarea of computational group theory
is to be able to do as much as possible with these matrix groups over
finite fields, guided by what is already possible efficiently for
finite permutation groups. The general idea is to use the complexity
analysis of algorithms as a tool to come up with ``efficient''
algorithms. Generally an algorithm is considered to be ``good'' if
its runtime is bounded from above by a polynomial in the size of the
input.

A first step in this direction is set out by the so-called matrix group
recognition project (see \cite{MatGrpProj} and \cite{OB}). This project
came to live after the seminal paper \cite{neumann-praeger} by Peter Neumann 
and Cheryl Praeger in 1992, in which they present an algorithm which decides,
whether or not a group $G = \left< g_1, \ldots, g_k\right> \le \GL(n,q)$
given by a set of generators contains the special linear group $\SL(n,q)$.
The matrix group recognition project in the meantime has become an ongoing 
collaborative effort of many researchers, and its aim
is to devise efficient algorithms to perform the constructive recognition
of a matrix group $G \le \GL(n,q)$ which is given by a set of generators. 
With the term ``constructive recognition'' we mean
\begin{itemize}
\setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
\item to find the group order $|G|$, and
\item to set up a procedure to 
\begin{itemize}
\setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
\item test whether an element $g \in \GL(n,q)$ is contained in $G$, and if so,
\item express $g$ explicitly as a word in the given generators.%
\footnote{For more details on the constructive recognition problem see
Section~\ref{constrrecog}.}
\end{itemize}
\end{itemize}
One good reason, why it is sensible to solve this problem for matrix groups
first, is that the extremely successful method of stabiliser chains and
bases and strong generating sets solves exactly
this problem for permutation groups and is one of the fundamental
algorithms for them. Therefore it is conceivable that an efficient solution
to the constructive recognition problem for matrix groups will provide a
similar fundament for the solution of further computational problems for
matrix groups.

The basic approach for the constructive recognition of matrix groups is
to compute a so-called composition tree for $G$. The nodes of this binary 
tree are groups together with a homomorphism to another group, the two
descendants of a node are the kernel and image of this homomorphism. The
leaves of the tree are simple groups, in which the constructive recognition
problem has to be solved by other means, and the root of the tree is $G$
itself. The infrastructure of the tree is organised such that a solution to
the constructive recognition problem for $G$ can be put together
by recursively traversing the tree and finally using the solutions to the
constructive recognition problems in the leaves. This description of the
composition tree here is
necessarily very rough, for details see \cite{MatGrpProj} or \cite{OB}
or Section~\ref{recapproach}.

\section{This Book}

The matrix group recognition project has produced many
results but is not yet fully completed.
This book gives an overview over the current state of the art and
shows some contributions of the author. The collaborative nature of the
whole project lends itself to joint papers by more than one person.
Therefore, some of the author's contributions to the project, which can
be found in Chapters~\ref{chap:charminpoly}, \ref{chap:comptree} and
\ref{chap:subsemi}, are in fact collaborations with other authors.

A second major part of the contributions of the author to the project lies
in actual implementations. Together with \'Akos Seress we have started an
implementation of the best known algorithms for group recognition in the
{\GAP} computer algebra system (see \cite{GAP4}). This implementation comes
in the form of two {\GAP} packages \textsf{recogbase} (see
\cite{recogbase}) and \textsf{recog} (see \cite{recog})
which are due to be published soon. The first provides a generic framework
to implement composition trees in {\GAP} for arbitrary types of groups. 
One interesting feature of the generic framework is that the type of group
can vary within a single composition tree. The
second package tries to collects the best known methods for group
recognition for permutation groups, matrix groups and projective groups.
Thus, everybody who contributes implementations will be an author of the
\textsf{recog} package. 

This book describes a major part of the algorithms used in both
packages. For some methods, mainly for the leaves of the composition tree,
the reader is however referred to the literature.

Since the matrix group project is not yet finished, the present work
cannot give a complete description of a solution to the constructive
recognition problem. In particular for the leaves of the composition tree
a lot of work and improvement of algorithms still has to be done, as is
explained in some detail in Chapter~\ref{chap:leaves}.

We have intentionally left out a number of topics which are related, mostly
because research on them is not completed or not even in a state for a
satisfactory description. One is
the whole field of algorithms for matrix groups that build on constructive
recognition. Derek Holt and Mark Stather have recently published a paper
\cite{HoltStather} pointing in that direction and Mark Stather's PhD thesis
\cite{StatherPhd} and \cite{StatherSylow} also lie in this area. 
Another area left out is the
constructive recognition of black box groups, because we wanted to
concentrate on matrix and projective groups. We only cover the
verification phase very briefly, which is however necessary to eventually
have computational proofs of the results. The reason for this is that in
fact very little work has been done on the actual implementation of
verification routines. What is needed for this is basically good
presentations for the groups occurring in the leaves. 
Finally a global analysis of the
whole procedure of building a composition tree is still needed. This seems
achievable using estimates on the length of a composition series but is not
yet done.

Now we turn to the things that are contained in this book and
outline its structure. 

Chapter~\ref{chap:intro} introduces briefly some concepts from computer
science which apply to computational group theory and describes a
way to produce nearly uniformly distributed random elements in a
finite group. Chapter~\ref{chap:cmats} describes a new method to
implement matrices over finite fields on a computer. Having an efficient
implementation of the finite field arithmetic and linear algebra
routines is obviously an indispensable foundation for implementing
matrix group algorithms. The contents of this chapter are not yet
published elsewhere.

Chapter~\ref{chap:charminpoly} contains a new randomised method to
compute the minimal polynomial of a square matrix over a finite field.
It is basically a copy of the paper \cite{minpolypaper} jointly
written by Cheryl Praeger and the author. Computing minimal
polynomials of invertible matrices is an important ingredient to compute the
order and projective order of such matrices, which are computations
that are used throughout nearly all matrix group algorithms.

Chapter~\ref{chap:linalg} completes the description of the
infrastructure for implementing matrix group algorithms by explaining
how to compute the order and projective order of a matrix and how to
perform higher level linear algebra computations like solving systems
of linear equations and inverting matrices. In addition the two
major obstacles for polynomial time algorithms, the discrete logarithm
problem and integer factorisation, are introduced. This chapter is
nothing new but is needed for the sake of completeness.

In Chapter~\ref{chap:comptree} we explain the basic problem attacked
by the matrix group recognition project, namely the constructive
recognition problem. We give a gentle introduction starting with a
rough formulation of the problem followed by two refinements. Then the
fundamental approach using composition trees and a generic framework
for group recognition are explained. We explain in detail the idea and
purpose of reduction homomorphisms. The
contents of this chapter are a variation and extension of the paper
\cite{AkosMaxISSAC} by \'Akos Seress and the author, in which the
composition tree approach is refined by allowing for a change in the generating
set of the group to be recognised. This refinement can dramatically
increase the performance because the resulting straight line programs
are much shorter than in the traditional version. Finally, the chapter
closes with a description how the currently best known algorithms for
the constructive recognition of permutation groups fit in nicely with
the proposed framework.

The next Chapter~\ref{chap:findhom} explains a variant of Aschbacher's
theorem on subgroups of classical groups restricted to the general linear
group case. A relatively short complete proof is given.
Our variant changes the definition of the occurring
classes of subgroups slightly to make it easier to devise algorithms
for finding reduction homomorphisms for groups in some of these classes.
This approach already seems to bear fruit in the last part of the
chapter where we present an overview over algorithms to find reduction
homomorphisms for groups in the different classes. For the new classes
\DD2, \DD4 and \DD7 new ideas to tackle groups in these classes are
given as well as references to the literature for the currently best
known methods.

Chapter~\ref{chap:subsemi} is a copy of the preprint \cite{subfieldpaper}
which is joint work of the author with Jon Carlson and Colva
Roney-Dougal. It presents new completely analysed randomised algorithms
to find a reduction for the case that $G \le \GL(n,q)$ acts irreducibly
on its natural module and lies in at least one of the semilinear or
subfield Aschbacher classes \CC3 and \CC5.

Chapter~\ref{chap:leaves} finally tries to summarise the state of the
art for algorithms to do constructive recognition for the leaves of
the composition tree, that is for groups in the Aschbacher classes
\CC8 and \CC9. We do not try to explain any of the best known
methods there because the final word on them seems not to be spoken
as of this writing. Rather, we explain the concepts of non-constructive
recognition and standard generators and give references to the
literature.

\section{Acknowledgements}

First and foremost I would like to thank Gerhard Hi\ss{} for a multitude
of things. He was not only my PhD supervisor but also gave me the
opportunity to be employed at the RWTH Aachen for 10 years in research
and teaching positions. He holds the chair of Lehrstuhl D f\"ur
Mathematik and thereby provided a superb environment for me to develop
from being a student of mathematics to be a professional mathematician.
I greatly enjoyed my time in Aachen and Gerhard Hi\ss{} has always been a
great advisor and good friend. I also thank the RWTH Aachen and in
particular all the people at Lehrstuhl D for the wonderful time I had
in Aachen.

I thank Alice Niemeyer and Cheryl Praeger for inviting me
repeatedly to the University of Western Australia in Perth for
research visits. During one of these visits I met \'Akos Seress, whom
I thank for motivating me to start working in the area of
computational matrix group theory, for successfully collaborating with
me over several years and for inviting me repeatedly to Columbus, Ohio
for research visits.

Furthermore I thank my coauthors Jon Carlson, Cheryl Praeger, 
Colva Roney-Dougal and \'Akos Seress for the interesting and fruitful
collaboration on a major part of the work that went into the present book.

I thank the University of St Andrews and in particular Steve Linton
for employing me since 2007 and giving me the opportunity to complete
the work on this book as part of my research job.

A big thank-you also goes to Colva Roney-Dougal who helped a lot in
proofreading and who agreed to constantly correct my English.

I wholeheartedly thank my parents for their permanent support and
for allowing me to have the long mathematics education I had, which
gave me the opportunity to get into my dream job.

Last but not least I would like to thank my wonderful wife Anja for
her constant support and encouragement during the completion of this
book.

\renewcommand{\thechapter}{\Roman{chapter}}
